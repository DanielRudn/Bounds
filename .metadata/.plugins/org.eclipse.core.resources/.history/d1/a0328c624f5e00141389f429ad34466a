package com.dr.bounds.maps;

import java.util.ArrayList;
import java.util.Random;

import com.DR.dLib.dImage;
import com.badlogic.gdx.graphics.Color;
import com.badlogic.gdx.graphics.Texture;
import com.badlogic.gdx.graphics.g2d.SpriteBatch;
import com.badlogic.gdx.math.Intersector;
import com.badlogic.gdx.math.Rectangle;
import com.dr.bounds.MainGame;
import com.dr.bounds.Player;

public class MapGenerator {

	// map generation type
	public static final int TYPE_DEFAULT = 1515, TYPE_SPACE = 3030, TYPE_MACHINERY = 6060;
	// the current map generation type
	private int currentType = TYPE_DEFAULT; 
	// ArrayList of obstacles in map, in an arraylist for easy adding/removing and modifying
	private ArrayList<dObstacle> obstacles = new ArrayList<dObstacle>();
	// Random number generator for positioning objects
	private Random rng = new Random();
	// seed for random number generator
	private long seed = 123456789;
	// player object to determine collisions
	private Player player;
	// useless REMOVE PLEASE
	Rectangle useless = new Rectangle();
	// whether or not the player had a collision
	private boolean hadCollision = false;
	// player score to give to game screen
	private int score = 0;
	// used to let gamescreen know that it should show the score change animation
	private boolean scoreChanged = false;
	
	/**
	 * Creates a new generator and sets the level type
	 * @param mapType Type of map to generate, use static attributes from this class as parameters
	 */
	public MapGenerator(int mapType, Texture obstacleTexture, Player player)
	{
		setMapType(mapType);
		this.player = player;
		generateSeed();
		if(mapType == TYPE_SPACE)
		{
			this.currentType = TYPE_SPACE;
			// add 5 obstacles to start with
			for(int x = 0; x < 5; x++)
			{
				obstacles.add(new dPlanetObstacle(0,0, new Texture("circle.png"), player));
				obstacles.get(x).setRegenerate(false);
			//	obstacles.get(x).setColor(Color.RED);
			}
		}
	//	obstacles.get(0).setY(MainGame.camera.position.y - MainGame.VIRTUAL_HEIGHT/2f - MIN_DISTANCE - rng.nextInt(MAX_DISTANCE));
	//	obstacles.get(0).setRegenerate(false);
		//TEST FOR MACHINE MAP TYPE

	}
	
	public void update(float delta)
	{
		// loop through all obstacles
		for(int x = 0; x < obstacles.size(); x++)
		{
			obstacles.get(x).update(delta);
			// check players score
			if(obstacles.get(x).hasPassed() && obstacles.get(x).hasIncrementedScore() == false)
			{
				score++;
				obstacles.get(x).setIncrementedScore(true);
				scoreChanged = true;
			}
			
			if(currentType == TYPE_DEFAULT)
			{

			}
			else if(currentType == TYPE_SPACE)
			{
				if(obstacles.get(x).shouldRegenerate())
				{
					generateDefault(x);
					obstacles.get(x).setRegenerate(false);
				}
				// check if player had collision
				if(obstacles.get(x).getClass().getName().equals(dPlanetObstacle.class.getName()))
				{
					if(((dPlanetObstacle)obstacles.get(x)).hasMoon() && Intersector.intersectRectangles(player.getBoundingRectangle(), ((dPlanetObstacle)obstacles.get(x)).getMoonBoundingRectangle(), useless))
					{
						hadCollision = true;
						obstacles.get(x).setColor(Color.BLUE);
						// send message to opponent saying player lost
						MainGame.requestHandler.sendReliableMessage(new byte[]{'L'});
						// test might have to remove
						break;
					}
				}
			}
		}
		
		

	}

	public void render(SpriteBatch batch)
	{
		for(int x = 0; x < obstacles.size(); x++)
		{
			obstacles.get(x).render(batch);
		}
	}
	
	public void setSeed(long s)
	{
		seed = s;
		rng.setSeed(seed);
	}
	
	public void generateSeed()
	{
		setSeed(Math.abs(rng.nextLong()));
	}
	
	private void setMapType(int mapType)
	{
		if(mapType != TYPE_DEFAULT || mapType != TYPE_SPACE)
		{
			currentType = TYPE_DEFAULT;
		}
		else
		{
			currentType = mapType;
		}
	}
	
	public void setHadCollision(boolean c)
	{
		hadCollision = c;
		if(c == false) // reset
		{
			//MainGame.setCameraPos(MainGame.VIRTUAL_WIDTH/2f, MainGame.VIRTUAL_HEIGHT / 2f);
			// reset obstacles
			for(int x = 0; x < obstacles.size(); x++)
			{
				obstacles.get(x).setY(0);
				obstacles.get(x).setRegenerate(true);
				//obstacles.get(x).setColor(Color.RED);
				obstacles.get(x).setPassed(false);
				obstacles.get(x).setIncrementedScore(true);
			}
			generateSeed();
			generateFirstSet();
			// reset backgrounds
		//	firstBG.setPos(0,0);
		//	secondBG.setPos(0,-MainGame.VIRTUAL_HEIGHT);
			score = 0;
		}
	}
	
	public void setScoreChanged(boolean scoreChanged)
	{
		this.scoreChanged = scoreChanged;
	}
	
	public void incrementScore()
	{
		score++;
	}
	
	public boolean hasScoreChanged()
	{
		return scoreChanged;
	}
	
	public int getScore()
	{
		return score;
	}
	
	public int getMapType()
	{
		return currentType;
	}
	
	public long getSeed()
	{
		return seed;
	}
	
	public boolean hadCollision()
	{
		return hadCollision;
	}
	
}
