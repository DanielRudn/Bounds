package com.dr.bounds;

import java.util.ArrayList;

import com.DR.dLib.ui.dScreen;
import com.DR.dLib.ui.dText;
import com.DR.dLib.ui.dUICard;
import com.DR.dLib.dValues;
import com.badlogic.gdx.ApplicationAdapter;
import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.Input.Keys;
import com.badlogic.gdx.audio.Sound;
import com.badlogic.gdx.graphics.GL20;
import com.badlogic.gdx.graphics.OrthographicCamera;
import com.badlogic.gdx.graphics.Texture;
import com.badlogic.gdx.graphics.Texture.TextureFilter;
import com.badlogic.gdx.graphics.g2d.SpriteBatch;
import com.dr.bounds.screens.DebugScreen;
import com.dr.bounds.screens.GameScreen;
import com.dr.bounds.screens.InboxScreen;
import com.dr.bounds.screens.InviteScreen;
import com.dr.bounds.screens.MenuScreen;
import com.dr.bounds.screens.MultiplayerScreen;
import com.dr.bounds.screens.WaitingRoomScreen;

public class MainGame extends ApplicationAdapter implements MultiplayerListener {
	
	/*==================================================
	 *					VARIABLES					   |
	 *=================================================*/
	
	// RequestHandler, Batch, Camera
	public static OrthographicCamera camera;
	private SpriteBatch batch;
	public static RequestHandler requestHandler;
	
	// CONSTANTS
	public static final float VIRTUAL_WIDTH = 720f, VIRTUAL_HEIGHT = 1280f, ASPECT_RATIO = VIRTUAL_WIDTH / VIRTUAL_HEIGHT;
	public static final int PLACEHOLDER_SKIN_ID = 0;
	
	// Textures, will be moved to an AssetManager class
	private Texture card, button, icon, obstacle, circle;
	
	// SCREENS
	public static dScreen currentScreen;
	public static dScreen previousScreen = null;
	public static MenuScreen menuScreen;
	public static GameScreen gameScreen;
	
	public static boolean isPlaying = false;
	
	// the time difference between frames
	private final float DELTA = 1f/60f;
	// the time each update call takes ?
	private float accumulator = 0f;
	
	// test, remove
	private static Sound scoreSound;
	private ArrayList<dUICard> recentlyPlayedList;
	
	private dText fpsText;
	
	public MainGame(RequestHandler h)
	{
		requestHandler = h;
	}
	
	@Override
	public void create () {
		Gdx.input.setCatchBackKey(true);
		camera = new OrthographicCamera(VIRTUAL_WIDTH, VIRTUAL_HEIGHT);
		camera.setToOrtho(true,VIRTUAL_WIDTH,VIRTUAL_HEIGHT);
		dValues.camera = camera;
		dValues.VH = VIRTUAL_HEIGHT;
		dValues.VW = VIRTUAL_WIDTH;
		
		button = new Texture("button.png");
		button.setFilter(TextureFilter.Linear, TextureFilter.Linear);
		card = new Texture("card.png");
		icon = new Texture("playerIcon.png");
		icon.setFilter(TextureFilter.Linear, TextureFilter.Linear);
		//obstacle = new Texture("obstacle.png");
		obstacle = new Texture("girder.png");
		obstacle.setFilter(TextureFilter.Linear, TextureFilter.Linear);
		circle = new Texture("circle.png");
		circle.setFilter(TextureFilter.Linear, TextureFilter.Linear);
		
		menuScreen = new MenuScreen(0,0,card);
		
		gameScreen = new GameScreen(0,0,card);
	//	gameScreen.pause();
		
		recentlyPlayedList = new ArrayList<dUICard>();
		
		batch = new SpriteBatch();
		
		scoreSound = Gdx.audio.newSound(Gdx.files.internal("score.wav"));
		
		fpsText = new dText(5,5,80,"FPS: 60");
		
		currentScreen = menuScreen;
		menuScreen.show();
	}

	@Override
	public void render () {
		Gdx.gl.glViewport(0,0, (int)Gdx.graphics.getWidth(), (int)Gdx.graphics.getHeight());
		Gdx.gl.glClearColor(189f/256f, 195f/256f, 199f/256f,.5f);
		Gdx.gl.glClear(GL20.GL_COLOR_BUFFER_BIT);
	
		if(Gdx.input.isKeyPressed(Keys.BACK) || Gdx.input.isKeyJustPressed(Keys.SPACE))
		{	
			currentScreen.goBack();
		}
		
		// UPDATE
		accumulator += Gdx.graphics.getDeltaTime();
		while(accumulator >= DELTA)
		{
			//inviteCard.update(DELTA);
			update(DELTA);
			fpsText.setPos(camera.position.x - MainGame.VIRTUAL_WIDTH / 2f + 5, camera.position.y - MainGame.VIRTUAL_HEIGHT / 2f + 5f);
			fpsText.setText("FPS: " + Gdx.graphics.getFramesPerSecond());
			accumulator -= DELTA;
		}

		batch.setProjectionMatrix(camera.combined);
		batch.begin();
		/*
		gameScreen.render(batch);
		debugCard.render(batch);
		inviteScreen.render(batch);
		waitingRoomScreen.render(batch);
		inviteCard.render(batch);
		*/
		currentScreen.render(batch);
		if(previousScreen != null)
		{
		//	previousScreen.render(batch);
		}
		fpsText.render(batch);
		batch.end();
		/**
		 * TODO: BUG: when inviting the nexus 5 from the memopad, if you swipe both away in the recents, and then invite from memo pad again, the nexus doesnt show info
		 */
	}
	
	public void update(float delta)
	{
		currentScreen.update(delta);
		if(previousScreen != null && currentScreen != previousScreen)
		{
		//	previousScreen.update(delta);
		}
		//update camera
		camera.update();
		// waiting room has moved away, start playing.
		if(waitingRoomScreen.getHideTime() >= 2f)
		{
			gameScreen.resume();
			currentScreen.switchScreen(gameScreen);
		}

	}
	
	public static int getVirtualMouseX()
	{
		return (int) (camera.position.x - VIRTUAL_WIDTH / 2f + (Gdx.input.getX() / (Gdx.graphics.getWidth() / VIRTUAL_WIDTH)));
	}
	
	public static int getVirtualMouseY()
	{
		return (int) (camera.position.y - VIRTUAL_HEIGHT / 2f + Gdx.input.getY() / (Gdx.graphics.getHeight() / VIRTUAL_HEIGHT));
	}
	
	public static void setCameraPos(float x, float y)
	{
		camera.position.set(x,y, camera.position.z);
	}
	
	public static void playScoreSound()
	{
		scoreSound.play();
	}

	public static int getPlayerSkinID()
	{
		return gameScreen.getPlayer().getSkinID();
	}
	
	/*
	 * MULTIPLAYER LISTENER METHODS
	 */
	
	@Override
	public void onConnected(){}

}
