package com.dr.bounds.maps;

import com.DR.dLib.dImage;
import com.badlogic.gdx.graphics.Texture;
import com.badlogic.gdx.graphics.g2d.SpriteBatch;
import com.badlogic.gdx.math.Intersector;
import com.badlogic.gdx.math.Rectangle;
import com.badlogic.gdx.math.Vector2;
import com.dr.bounds.MainGame;
import com.dr.bounds.Player;
import com.dr.bounds.screens.GameScreen;

public class SpaceMapType extends MapType {

	// useless
	private Rectangle useless = new Rectangle(0,0,0,0);
	// tile-able backgrounds for current map type
	private dImage firstBG, secondBG;
	
	public SpaceMapType(int type, Player player, MapGenerator generator) {
		super(type, player, generator);
		MIN_DISTANCE = MAX_DISTANCE;
		MAX_DISTANCE *= 2;
		MIN_WIDTH = 192;
		MAX_WIDTH = 256;
		
		typeName = "Space";
		// add 2 obstacles to start with
		for(int x = 0; x < 2; x++)
		{
			obstacles.add(new dPlanetObstacle(0,0, new Texture("circle.png"), player, MapGenerator.rng));
			obstacles.get(x).setRegenerate(false);
		}
		
		firstBG = new dImage(0,0, new Texture("SPACE_BG.png"));
		secondBG = new dImage(0,-MainGame.VIRTUAL_HEIGHT, new Texture("SPACE_BG.png"));
	}
	
	@Override
	public void render(SpriteBatch batch)
	{
		firstBG.render(batch);
		secondBG.render(batch);
		super.render(batch);
	}

	@Override
	public void update(float delta) {
		for(int x = 0; x < obstacles.size(); x++)
		{
			obstacles.get(x).update(delta);
			if(obstacles.get(x).shouldRegenerate())
			{
				generateDefault(x);
				obstacles.get(x).setRegenerate(false);
			}
			// check if player had collision
			if(obstacles.get(x).getClass().getName().equals(dPlanetObstacle.class.getName()))
			{
				if(((dPlanetObstacle)obstacles.get(x)).hasMoon() && Intersector.intersectRectangles(player.getBoundingRectangle(), ((dPlanetObstacle)obstacles.get(x)).getMoonBoundingRectangle(), useless))
				{
					if(gen.hadCollision() == false)
					{
						// send message to opponent saying player lost
						MainGame.requestHandler.sendReliableMessage(new byte[]{'L'});
					}
					gen.setHadCollision(true);
					// test might have to remove
					break;
				}
				if(hadCirclularCollision(obstacles.get(x).getPos(), player.getPos(), x))
				{
					// send message to opponent saying player lost
					MainGame.requestHandler.sendReliableMessage(new byte[]{'L'});
					gen.setHadCollision(true);
					// test might have to remove
					break;
				}
			}
		}
		
		// update backgrounds
		if(firstBG.getY() >= MainGame.camera.position.y + MainGame.VIRTUAL_HEIGHT / 2f)
		{
			firstBG.setY(secondBG.getY() - firstBG.getHeight());
		}
		if(secondBG.getY() >= MainGame.camera.position.y + MainGame.VIRTUAL_HEIGHT / 2f)
		{
			secondBG.setY(firstBG.getY() - secondBG.getHeight());
		}
	}
	

	private boolean hadCirclularCollision(Vector2 f, Vector2 i, int index)
	{
		float radiusPlanet = obstacles.get(index).getWidth() / 2f;
		float radiusPlayer = player.getWidth() / 2f;
		return Math.pow((f.x + radiusPlanet) - (i.x + radiusPlayer), 2) + Math.pow((f.y + radiusPlanet) - (i.y + radiusPlayer), 2) <= Math.pow(radiusPlanet + radiusPlayer, 2); 
	}
	
	@Override
	protected void generateDefault(int index)
	{
		//reset passed for this obstacles
		obstacles.get(index).setPassed(false);
		int side = MapGenerator.rng.nextInt(11); // 0,1,5,6,7 is LEFT, 2,3,8,9,10 is RIGHT, 4 is center
		if(side == 0 || side == 1 || side == 5 || side == 6 || side == 7)// left
		{
			obstacles.get(index).setWidth(MIN_WIDTH + MapGenerator.rng.nextInt(MAX_WIDTH));
			obstacles.get(index).setHeight(obstacles.get(index).getWidth());
			obstacles.get(index).setX(32f);
		}
		else if(side == 2 || side == 3 || side == 8 || side == 9 || side == 10)// right
		{
			obstacles.get(index).setWidth(MIN_WIDTH + MapGenerator.rng.nextInt(MAX_WIDTH));
			obstacles.get(index).setHeight(obstacles.get(index).getWidth());
			obstacles.get(index).setX(MainGame.VIRTUAL_WIDTH - obstacles.get(index).getWidth() - 32f);
		}
		else if(side == 4)// center
		{
			obstacles.get(index).setWidth(MIN_WIDTH + MapGenerator.rng.nextInt(MAX_WIDTH) - 32f);
			obstacles.get(index).setHeight(obstacles.get(index).getWidth());
			obstacles.get(index).setX(MainGame.VIRTUAL_WIDTH / 2f - obstacles.get(index).getWidth() / 2f + (-50 + MapGenerator.rng.nextInt(100)));
		}
		((dPlanetObstacle)obstacles.get(index)).generate();
		obstacles.get(index).setY(obstacles.get(getPreviousIndex(index)).getY() - MIN_DISTANCE - MapGenerator.rng.nextInt(MAX_DISTANCE));
		GameScreen.log("space generateDefault()");
	}
	
	@Override
	public void reset()
	{
		// reset backgrounds
		firstBG.setPos(0,0);
		secondBG.setPos(0,-MainGame.VIRTUAL_HEIGHT);
	}

}
